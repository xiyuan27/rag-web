#
#  Copyright 2024 The InfiniFlow Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
import binascii
import logging
import re
import time
from copy import deepcopy
from datetime import datetime
from functools import partial
from timeit import default_timer as timer

from langfuse import Langfuse

from agentic_reasoning import DeepResearcher
from api import settings
from api.db import LLMType, ParserType, StatusEnum
from api.db.db_models import DB, Dialog
from api.db.services.common_service import CommonService
from api.db.services.knowledgebase_service import KnowledgebaseService
from api.db.services.langfuse_service import TenantLangfuseService
from api.db.services.llm_service import LLMBundle, TenantLLMService
from api.utils import current_timestamp, datetime_format
from rag.app.resume import forbidden_select_fields4resume
from rag.app.tag import label_question
from rag.nlp.search import index_name
from rag.prompts import chunks_format, citation_prompt, cross_languages, full_question, kb_prompt, keyword_extraction, \
    llm_id2llm_type, message_fit_in
from rag.utils import num_tokens_from_string, rmSpace
from rag.utils.tavily_conn import Tavily


class DialogService(CommonService):
    model = Dialog

    @classmethod
    def save(cls, **kwargs):
        """Save a new record to database.

        This method creates a new record in the database with the provided field values,
        forcing an insert operation rather than an update.

        Args:
            **kwargs: Record field values as keyword arguments.

        Returns:
            Model instance: The created record object.
        """
        sample_obj = cls.model(**kwargs).save(force_insert=True)
        return sample_obj

    @classmethod
    def update_many_by_id(cls, data_list):
        """Update multiple records by their IDs.

        This method updates multiple records in the database, identified by their IDs.
        It automatically updates the update_time and update_date fields for each record.

        Args:
            data_list (list): List of dictionaries containing record data to update.
                             Each dictionary must include an 'id' field.
        """
        with DB.atomic():
            for data in data_list:
                data["update_time"] = current_timestamp()
                data["update_date"] = datetime_format(datetime.now())
                cls.model.update(data).where(cls.model.id == data["id"]).execute()

    @classmethod
    @DB.connection_context()
    def get_list(cls, tenant_id, page_number, items_per_page, orderby, desc, id, name):
        chats = cls.model.select()
        if id:
            chats = chats.where(cls.model.id == id)
        if name:
            chats = chats.where(cls.model.name == name)
        chats = chats.where((cls.model.tenant_id == tenant_id) & (cls.model.status == StatusEnum.VALID.value))
        if desc:
            chats = chats.order_by(cls.model.getter_by(orderby).desc())
        else:
            chats = chats.order_by(cls.model.getter_by(orderby).asc())

        chats = chats.paginate(page_number, items_per_page)

        return list(chats.dicts())


def chat_solo(dialog, messages, stream=True):
    """
       Á∫ØÁ∫ØËÅäÂ§©Ê®°ÂºèÔºà‰∏ç‰ΩøÁî®Áü•ËØÜÂ∫ìÊ£ÄÁ¥¢Ôºâ
    """
    print("Á∫ØÁ∫ØËÅäÂ§©Ê®°ÂºèÔºà‰∏ç‰ΩøÁî®Áü•ËØÜÂ∫ìÊ£ÄÁ¥¢Ôºâ")
    if llm_id2llm_type(dialog.llm_id) == "image2text":
        chat_mdl = LLMBundle(dialog.tenant_id, LLMType.IMAGE2TEXT, dialog.llm_id)
    else:
        chat_mdl = LLMBundle(dialog.tenant_id, LLMType.CHAT, dialog.llm_id)

    prompt_config = dialog.prompt_config
    tts_mdl = None
    if prompt_config.get("tts"):
        tts_mdl = LLMBundle(dialog.tenant_id, LLMType.TTS)
    msg = [{"role": m["role"], "content": re.sub(r"##\d+\$\$", "", m["content"])} for m in messages if
           m["role"] != "system"]
    if stream:
        last_ans = ""
        delta_ans = ""
        print("chat_solo--Ë∞ÉÁî®Â§ßÊ®°ÂûãÔºåÊµÅÂºèÈÄêÊ≠•ÁîüÊàêÁ≠îÊ°à")
        for ans in chat_mdl.chat_streamly(prompt_config.get("system", ""), msg, dialog.llm_setting):
            answer = ans
            delta_ans = ans[len(last_ans):]
            if num_tokens_from_string(delta_ans) < 16:
                continue
            last_ans = answer
            yield {"answer": answer, "reference": {}, "audio_binary": tts(tts_mdl, delta_ans), "prompt": "",
                   "created_at": time.time()}
            delta_ans = ""
        if delta_ans:
            yield {"answer": answer, "reference": {}, "audio_binary": tts(tts_mdl, delta_ans), "prompt": "",
                   "created_at": time.time()}
    else:
        answer = chat_mdl.chat(prompt_config.get("system", ""), msg, dialog.llm_setting)
        user_content = msg[-1].get("content", "[content not available]")
        logging.debug("User: {}|Assistant: {}".format(user_content, answer))
        yield {"answer": answer, "reference": {}, "audio_binary": tts(tts_mdl, answer), "prompt": "",
               "created_at": time.time()}


def get_models(dialog):
    print("Ê†πÊçÆÂØπËØùÈÖçÁΩÆÂàùÂßãÂåñÊâÄÈúÄÁöÑÊ®°ÂûãÂÆû‰æã")
    embd_mdl, chat_mdl, rerank_mdl, tts_mdl = None, None, None, None
    kbs = KnowledgebaseService.get_by_ids(dialog.kb_ids)
    embedding_list = list(set([kb.embd_id for kb in kbs]))
    if len(embedding_list) > 1:
        raise Exception("**ERROR**: Knowledge bases use different embedding models.")

    if embedding_list:
        embd_mdl = LLMBundle(dialog.tenant_id, LLMType.EMBEDDING, embedding_list[0])
        if not embd_mdl:
            raise LookupError("Embedding model(%s) not found" % embedding_list[0])

    if llm_id2llm_type(dialog.llm_id) == "image2text":
        chat_mdl = LLMBundle(dialog.tenant_id, LLMType.IMAGE2TEXT, dialog.llm_id)
    else:
        chat_mdl = LLMBundle(dialog.tenant_id, LLMType.CHAT, dialog.llm_id)

    if dialog.rerank_id:
        rerank_mdl = LLMBundle(dialog.tenant_id, LLMType.RERANK, dialog.rerank_id)

    if dialog.prompt_config.get("tts"):
        tts_mdl = LLMBundle(dialog.tenant_id, LLMType.TTS)
    return kbs, embd_mdl, rerank_mdl, chat_mdl, tts_mdl


BAD_CITATION_PATTERNS = [
    re.compile(r"\(\s*ID\s*[: ]*\s*(\d+)\s*\)"),  # (ID: 12)
    re.compile(r"\[\s*ID\s*[: ]*\s*(\d+)\s*\]"),  # [ID: 12]
    re.compile(r"„Äê\s*ID\s*[: ]*\s*(\d+)\s*„Äë"),  # „ÄêID: 12„Äë
    re.compile(r"ref\s*(\d+)", flags=re.IGNORECASE),  # ref12„ÄÅREF 12
]


def repair_bad_citation_formats(answer: str, kbinfos: dict, idx: set):
    max_index = len(kbinfos["chunks"])

    def safe_add(i):
        if 0 <= i < max_index:
            idx.add(i)
            return True
        return False

    def find_and_replace(pattern, group_index=1, repl=lambda i: f"ID:{i}", flags=0):
        nonlocal answer

        def replacement(match):
            try:
                i = int(match.group(group_index))
                if safe_add(i):
                    return f"[{repl(i)}]"
            except Exception:
                pass
            return match.group(0)

        answer = re.sub(pattern, replacement, answer, flags=flags)

    for pattern in BAD_CITATION_PATTERNS:
        find_and_replace(pattern)

    return answer, idx


def chat(dialog, messages, stream=True, **kwargs):
    """
       ÂÆûÁé∞ÂÆåÊï¥ÁöÑRAGÂØπËØùÊµÅÁ®ã
       Args:
           dialog: Êô∫ËÉΩÂä©ÊâãÈÖçÁΩÆ‰ø°ÊÅØ
           messages: Ê∂àÊÅØÂéÜÂè≤ÂàóË°®
           stream: ÊòØÂê¶ÊµÅÂºèËæìÂá∫
           **kwargs: ÂÖ∂‰ªñÂèÇÊï∞
       """
    logging.info("=" * 80)
    logging.info(" RAGÂØπËØùÊµÅÁ®ãÂºÄÂßã")
    logging.info("=" * 80)

    logging.info("\n [Èò∂ÊÆµ1] ÂºÄÂßã - ÂàùÂßãÂåñÂíåÈ™åËØÅ")
    assert messages[-1]["role"] == "user", "The last content of this conversation is not from user."
    logging.info(f" È™åËØÅÈÄöËøá - ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÊù•Ëá™Áî®Êà∑: {messages[-1]['content'][:50]}...")

    # Â¶ÇÊûúÊ≤°ÊúâÁü•ËØÜÂ∫ì‰∏îÊ≤°ÊúâTavily APIÂØÜÈí•ÔºåÂàô‰ΩøÁî®ÁÆÄÂçïÂØπËØùÊ®°Âºè
    if not dialog.kb_ids and not dialog.prompt_config.get("tavily_api_key"):
        logging.info(" ‰ΩøÁî®ÁÆÄÂçïÂØπËØùÊ®°ÂºèÔºàÂõ†‰∏∫Êó†Áü•ËØÜÂ∫ìÔºå‰∏îÊó†ËÅîÁΩëÊêúÁ¥¢-tavily_api_key‰∏∫Á©∫.Ôºâ")
        for ans in chat_solo(dialog, messages, stream):
            yield ans
        return
    logging.info(" [Èò∂ÊÆµ1] ÂÆåÊàê - ÂàùÂßãÂåñÂíåÈ™åËØÅ")

    chat_start_ts = timer()  # ÂØπËØùÂºÄÂßãÊó∂Èó¥

    # ===== Èò∂ÊÆµ2: Ê®°ÂûãÈÖçÁΩÆËé∑Âèñ =====
    logging.info("[Èò∂ÊÆµ2] ÂºÄÂßã - Ê®°ÂûãÈÖçÁΩÆËé∑Âèñ")
    # Ê†πÊçÆLLMÁ±ªÂûãËé∑ÂèñÊ®°ÂûãÈÖçÁΩÆ(ÂõæÁâáËß£ËØªÊ®°Âûã/ËÅäÂ§©Ê®°Âûã)
    if llm_id2llm_type(dialog.llm_id) == "image2text":
        llm_model_config = TenantLLMService.get_model_config(dialog.tenant_id, LLMType.IMAGE2TEXT, dialog.llm_id)
        logging.info(f"üñº‰ΩøÁî®ÂõæÂÉèËΩ¨ÊñáÊú¨Ê®°Âûã: {dialog.llm_id}")
    else:
        llm_model_config = TenantLLMService.get_model_config(dialog.tenant_id, LLMType.CHAT, dialog.llm_id)
        logging.info(f"‰ΩøÁî®ËÅäÂ§©Ê®°Âûã: {dialog.llm_id}")

    max_tokens = llm_model_config.get("max_tokens", 8192)  # Ëé∑ÂèñÊ®°ÂûãÊúÄÂ§ßtokenÊï∞ÈôêÂà∂ÔºåÈªòËÆ§8192
    logging.info(f" ÊúÄÂ§ßtokenÈôêÂà∂: {max_tokens}")
    logging.info("[Èò∂ÊÆµ2] ÂÆåÊàê - Ê®°ÂûãÈÖçÁΩÆËé∑Âèñ")


    check_llm_ts = timer()  # llmÂºÄÂßãÊó∂Èó¥

    # ===== Èò∂ÊÆµ3: LangfuseÁõëÊéßÂàùÂßãÂåñ =====
    logging.info("[Èò∂ÊÆµ3] ÂºÄÂßã - LangfuseÁõëÊéßÂàùÂßãÂåñ")
    # ÂàùÂßãÂåñLangfuseËøΩË∏™Âô®ÔºàÁî®‰∫éÁõëÊéßÂíåÂàÜÊûêÔºâ
    langfuse_tracer = None
    # ‰ªéÊï∞ÊçÆÂ∫ìÊü•ËØ¢LangfuseÂØÜÈí•, Êàë‰ª¨ÁõÆÂâçtenant_langfuseË°®Êó†Êï∞ÊçÆÔºåÊâÄ‰ª•langfuse_keys‰∏∫Á©∫„ÄÇ
    langfuse_keys = TenantLangfuseService.filter_by_tenant(tenant_id=dialog.tenant_id)
    if langfuse_keys:
        print("Langfuse keys found")
        langfuse = Langfuse(public_key=langfuse_keys.public_key, secret_key=langfuse_keys.secret_key,
                            host=langfuse_keys.host)
        if langfuse.auth_check():
            langfuse_tracer = langfuse
            langfuse.trace = langfuse_tracer.trace(name=f"{dialog.name}-{llm_model_config['llm_name']}")

    check_langfuse_tracer_ts = timer()

    # ===== Èò∂ÊÆµ4: Ê®°ÂûãÁªëÂÆö =====
    logging.info(" [Èò∂ÊÆµ4] ÂºÄÂßã - Ê®°ÂûãÁªëÂÆö")
    # Ê†πÊçÆÊô∫ËÉΩÂä©ÁêÜÔºàdialogÔºâÈÖçÁΩÆÔºåËé∑ÂèñÊ®°ÂûãÂÆû‰æã
    # - kbs: Áü•ËØÜÂ∫ìÂØπË±°ÂàóË°®Ôºåembd_mdl: ÂµåÂÖ•Ê®°ÂûãÔºå rerank_mdl: ÈáçÊéíÂ∫èÊ®°ÂûãÔºåchat_mdl: ËÅäÂ§©Ê®°ÂûãÔºåtts_mdl: ËØ≠Èü≥ÂêàÊàêÊ®°Âûã
    kbs, embd_mdl, rerank_mdl, chat_mdl, tts_mdl = get_models(dialog)
    # Ëé∑ÂèñÂ∑•ÂÖ∑Ë∞ÉÁî®‰ºöËØùÂíåÂ∑•ÂÖ∑ÂàóË°®
    toolcall_session, tools = kwargs.get("toolcall_session"), kwargs.get("tools")
    if toolcall_session and tools:
        # Â¶ÇÊûúÊúâÂ∑•ÂÖ∑ÔºåÂàôÁªëÂÆöÂà∞ËÅäÂ§©Ê®°Âûã
        logging.info(f"üîß ÁªëÂÆöÂ∑•ÂÖ∑Êï∞Èáè: {len(tools)}")
        chat_mdl.bind_tools(toolcall_session, tools)
    bind_models_ts = timer()

    # ===== Èò∂ÊÆµ5: ÈóÆÈ¢òÈ¢ÑÂ§ÑÁêÜ =====
    logging.info(" [Èò∂ÊÆµ5] ÂºÄÂßã - ÈóÆÈ¢òÈ¢ÑÂ§ÑÁêÜ")
    # # Ëé∑ÂèñÊ£ÄÁ¥¢Âô®ÂÆû‰æã(Âç≥Âè¨ÂõûÁ≥ªÁªü)
    retriever = settings.retrievaler
    # ÊèêÂèñÊúÄËøë3Êù°Áî®Êà∑Ê∂àÊÅØ‰Ωú‰∏∫ÈóÆÈ¢òÂàóË°®
    questions = [m["content"] for m in messages if m["role"] == "user"][-3:]
    logging.info(f"ÊèêÂèñÁî®Êà∑ÈóÆÈ¢òÊï∞Èáè: {len(questions)}")
    logging.info(f"ÊúÄÊñ∞ÈóÆÈ¢ò: {questions[-1][:100]}...")
    # Â§ÑÁêÜÊñáÊ°£ÈôÑ‰ª∂ID
    attachments = kwargs["doc_ids"].split(",") if "doc_ids" in kwargs else None
    if "doc_ids" in messages[-1]:
        attachments = messages[-1]["doc_ids"]

    # Ëé∑ÂèñÊèêÁ§∫ÈÖçÁΩÆÂíåÂ≠óÊÆµÊò†Â∞Ñ
    prompt_config = dialog.prompt_config
    field_map = KnowledgebaseService.get_field_map(dialog.kb_ids)
    # Â∞ùËØï‰ΩøÁî®SQLÊ£ÄÁ¥¢ÔºàÂ¶ÇÊûúÂ≠óÊÆµÊò†Â∞ÑÂèØÁî®Ôºâ
    if field_map:
        logging.debug("Use SQL to retrieval:{}".format(questions[-1]))  # ‰ΩøÁî®SQLÊü•ËØ¢Ëé∑ÂèñÁ≠îÊ°à
        ans = use_sql(questions[-1], field_map, dialog.tenant_id, chat_mdl, prompt_config.get("quote", True))
        if ans:
            yield ans
            return

    # Ê£ÄÊü•ÂøÖÈúÄÂèÇÊï∞ÊòØÂê¶Â≠òÂú®
    for p in prompt_config["parameters"]:
        if p["key"] == "knowledge":
            continue
        # Ê£ÄÊü•ÈùûoptionalÂèÇÊï∞ÊòØÂê¶ÈΩêÂ§á
        if p["key"] not in kwargs and not p["optional"]:
            raise KeyError("Miss parameter: " + p["key"])
        # Â¶ÇÊûúÂèØÈÄâÂèÇÊï∞(optional)Áº∫Â§±ÔºåÁî®Á©∫Ê†ºÊõøÊç¢Âç†‰ΩçÁ¨¶
        if p["key"] not in kwargs:
            prompt_config["system"] = prompt_config["system"].replace("{%s}" % p["key"], " ")

    # ===== Èò∂ÊÆµ6: ÈóÆÈ¢òÁ≤æÂåñ =====
    logging.info(" [Èò∂ÊÆµ6] ÂºÄÂßã - ÈóÆÈ¢òÁ≤æÂåñ")
    #  Â§ÑÁêÜÂ§öËΩÆÂØπËØùÁöÑÈóÆÈ¢òÁ≤æÂåñ
    if len(questions) > 1 and prompt_config.get("refine_multiturn"):
        # Â§öËΩÆÂØπËØùÊ®°ÂºèÔºöÂ∞ÜÂéÜÂè≤ÂØπËØù‰∏ä‰∏ãÊñáÂêàÂπ∂‰∏∫‰∏Ä‰∏™ÂÆåÊï¥„ÄÅÁã¨Á´ãÁöÑÈóÆÈ¢ò
        # ‰æãÂ¶ÇÔºöÁî®Êà∑ÈóÆ"ÁâπÊúóÊôÆÁöÑÁà∂‰∫≤Âè´‰ªÄ‰πà?" -> "Fred Trump" -> "‰ªñÁöÑÊØç‰∫≤Âë¢?" ‰ºöË¢´Á≤æÂåñ‰∏∫Ôºö"ÁâπÊúóÊôÆÁöÑÊØç‰∫≤Âè´‰ªÄ‰πàÂêçÂ≠ó?"
        questions = [full_question(dialog.tenant_id, dialog.llm_id, messages)]
    else:
        # ÂçïËΩÆÂØπËØùÊ®°ÂºèÔºöÂè™‰ΩøÁî®Áî®Êà∑ÁöÑÊúÄÊñ∞ÈóÆÈ¢òÔºåÂøΩÁï•ÂéÜÂè≤‰∏ä‰∏ãÊñá
        questions = questions[-1:]

    # Ë∑®ËØ≠Ë®ÄÊü•ËØ¢Êâ©Â±ï
    if prompt_config.get("cross_languages"):
        # Â∞ÜÈóÆÈ¢òÁøªËØëÊàêÂ§öÁßçËØ≠Ë®Ä‰ª•ÊèêÂçáÊ£ÄÁ¥¢Ë¶ÜÁõñÁéá
        # ‰æãÂ¶ÇÔºöËã±ÊñáÈóÆÈ¢òÂêåÊó∂ÁîüÊàê‰∏≠Êñá„ÄÅÊó•ÊñáÁâàÊú¨ËøõË°åÊ£ÄÁ¥¢, ËøôÊ†∑ÂèØ‰ª•Ê£ÄÁ¥¢Âà∞‰∏çÂêåËØ≠Ë®ÄÁöÑÁõ∏ÂÖ≥ÊñáÊ°£
        questions = [cross_languages(dialog.tenant_id, dialog.llm_id, questions[0], prompt_config["cross_languages"])]

    # ÂÖ≥ÈîÆËØçÊèêÂèñÂ¢ûÂº∫Êü•ËØ¢
    if prompt_config.get("keyword", False):
        # ‰ªéÁî®Êà∑ÈóÆÈ¢ò‰∏≠ÊèêÂèñÂÖ≥ÈîÆËØçÂπ∂ËøΩÂä†Âà∞ÂéüÈóÆÈ¢òÂêé
        # ‰æãÂ¶ÇÔºö"Â¶Ç‰Ωï‰ΩøÁî®PythonËøõË°åÊï∞ÊçÆÂàÜÊûê?" + "Python, Êï∞ÊçÆÂàÜÊûê, Êú∫Âô®Â≠¶‰π†", ËøôÊ†∑ÂèØ‰ª•ÊèêÂçáÂêëÈáèÊ£ÄÁ¥¢ÁöÑÂè¨ÂõûÁéá
        questions[-1] += keyword_extraction(chat_mdl, questions[-1])

    logging.info(questions)
    refine_question_ts = timer()

    # ===== Èò∂ÊÆµ7: Áü•ËØÜÊ£ÄÁ¥¢ =====
    logging.info(" [Èò∂ÊÆµ7] ÂºÄÂßã - Áü•ËØÜÊ£ÄÁ¥¢")
    # ÂàùÂßãÂåñÊé®ÁêÜÊÄùËÄÉËøáÁ®ãÂíåÁü•ËØÜÂ∫ìÊ£ÄÁ¥¢ÁªìÊûú
    thought = ""  # Â≠òÂÇ®Êé®ÁêÜÊ®°Âºè‰∏ãÁöÑÊÄùËÄÉËøáÁ®ãÊñáÊú¨
    # Áü•ËØÜÂ∫ìÊ£ÄÁ¥¢ÁªìÊûúÁöÑÊ†áÂáÜÂåñÊ†ºÂºè
    # total:Ê£ÄÁ¥¢Âà∞ÁöÑÊÄªÊñáÊ°£Êï∞ chunks:ÊñáÊ°£ÁâáÊÆµÂàóË°®ÔºåÊØè‰∏™ÁâáÊÆµÂåÖÂê´ÂÜÖÂÆπ„ÄÅÂêëÈáè„ÄÅÂÖÉÊï∞ÊçÆÁ≠â
    # doc_aggs:ÊñáÊ°£ËÅöÂêà‰ø°ÊÅØÔºåÂåÖÂê´ÊñáÊ°£Á∫ßÂà´ÁöÑÁªüËÆ°ÂíåÂÖÉÊï∞ÊçÆ
    kbinfos = {"total": 0, "chunks": [], "doc_aggs": []}
    # Ê£ÄÊü•Áü•ËØÜÊ£ÄÁ¥¢ÈÖçÁΩÆÔºöÂà§Êñ≠ÊòØÂê¶ÈúÄË¶ÅËøõË°åÁü•ËØÜÂ∫ìÊ£ÄÁ¥¢
    if "knowledge" not in [p["key"] for p in prompt_config["parameters"]]:
        # Â¶ÇÊûúpromptÈÖçÁΩÆ‰∏≠Ê≤°Êúâ"knowledge"ÂèÇÊï∞ÔºåËØ¥ÊòéËøôÊòØÁ∫ØËÅäÂ§©Ê®°Âºè
        # ‰∏çÈúÄË¶ÅÊ£ÄÁ¥¢Â§ñÈÉ®Áü•ËØÜÔºåÁõ¥Êé•‰ΩøÁî®LLMÁöÑÂÜÖÁΩÆÁü•ËØÜÂõûÁ≠î
        knowledges = []
    else:
        # ÈúÄË¶ÅËøõË°åÁü•ËØÜÊ£ÄÁ¥¢ÁöÑÊ®°Âºè,Ëé∑ÂèñÊâÄÊúâÁõ∏ÂÖ≥Áü•ËØÜÂ∫ìÁöÑÁßüÊà∑IDÔºàÂéªÈáçÂ§ÑÁêÜÔºâ
        tenant_ids = list(set([kb.tenant_id for kb in kbs]))
        knowledges = []  # ÂàùÂßãÂåñÁü•ËØÜÂÜÖÂÆπÂàóË°®
        # Êô∫ËÉΩÊé®ÁêÜ(reasoning)Ê®°Âºè vs Ê†áÂáÜÊ£ÄÁ¥¢Ê®°ÂºèÁöÑÂàÜÊîØÂ§ÑÁêÜ
        if prompt_config.get("reasoning", False):
            # == = Êô∫ËÉΩÊé®ÁêÜÊ®°Âºè == =
            # ‰ΩøÁî®DeepResearcherËøõË°åÂ§öÊ≠•È™§Êé®ÁêÜÂíåÁü•ËØÜÊ£ÄÁ¥¢, ËøôÁßçÊ®°Âºè‰ºöËøõË°åÊõ¥Ê∑±ÂÖ•ÁöÑÂàÜÊûêÔºåÁ±ª‰ºº‰∫éAIÁ†îÁ©∂Âä©Êâã
            reasoner = DeepResearcher(
                chat_mdl,  # ËÅäÂ§©Ê®°ÂûãÔºåÁî®‰∫éÊé®ÁêÜÂàÜÊûê
                prompt_config,  # ÊèêÁ§∫ÈÖçÁΩÆ
                # ÂàõÂª∫Ê£ÄÁ¥¢ÂáΩÊï∞ÁöÑÂÅèÂáΩÊï∞ÔºåÈ¢ÑËÆæÊâÄÊúâÊ£ÄÁ¥¢ÂèÇÊï∞
                #   retriever.retrieval Ê£ÄÁ¥¢Âô®ÁöÑÊ£ÄÁ¥¢ÊñπÊ≥ï;  embd_mdl:ÂµåÂÖ•Ê®°Âûã; tenant_ids:ÁßüÊà∑IDÂàóË°®;kb_ids:Áü•ËØÜÂ∫ìIDÂàóË°®
                #   similarity_threshold:Áõ∏‰ººÂ∫¶ÈòàÂÄºÔºà0.2ËæÉ‰ΩéÔºåÂè¨ÂõûÊõ¥Â§öÔºâ; vector_similarity_weight:ÂêëÈáèÁõ∏‰ººÂ∫¶ÊùÉÈáç
                partial(retriever.retrieval, embd_mdl=embd_mdl, tenant_ids=tenant_ids, kb_ids=dialog.kb_ids, page=1,
                        page_size=dialog.top_n, similarity_threshold=0.2, vector_similarity_weight=0.3),
            )
            # ÊâßË°åÊé®ÁêÜÊÄùËÄÉÂæ™ÁéØ
            for think in reasoner.thinking(kbinfos, " ".join(questions)):
                # Â¶ÇÊûúËøîÂõûÁöÑÊòØÂ≠óÁ¨¶‰∏≤ÔºåËØ¥ÊòéÊòØÊúÄÁªàÁöÑÊÄùËÄÉÁªìÊûú
                if isinstance(think, str):
                    thought = think  # ‰øùÂ≠òÂÆåÊï¥ÊÄùËÄÉËøáÁ®ã
                    knowledges = [t for t in think.split("\n") if t]  # ÊåâË°åÂàÜÂâ≤Âπ∂ËøáÊª§Á©∫Ë°å
                elif stream:
                    # Â¶ÇÊûúËøîÂõûÁöÑÊòØÊµÅÂºèÊï∞ÊçÆ‰∏îÂºÄÂêØ‰∫ÜÊµÅÂºèËæìÂá∫,ÂÆûÊó∂ÂêëÁî®Êà∑Â±ïÁ§∫Êé®ÁêÜËøáÁ®ãÔºàÂ¶Ç"Ê≠£Âú®ÂàÜÊûê..."Ôºâ
                    yield think
        else:
            # === Ê†áÂáÜÊ£ÄÁ¥¢Ê®°Âºè ===
            # ‰º†ÁªüÁöÑÂêëÈáèÊ£ÄÁ¥¢ + ÂèØÈÄâÁöÑÂ§öÊ∫êÊ£ÄÁ¥¢Â¢ûÂº∫
            # 1. ÂêëÈáèÊ£ÄÁ¥¢ÔºàÊ†∏ÂøÉÊ£ÄÁ¥¢Ôºâ
            if embd_mdl:
                # ÊâßË°åËØ≠‰πâÂêëÈáèÊ£ÄÁ¥¢(ÂêëÈáèÂè¨Âõû)
                kbinfos = retriever.retrieval(
                    " ".join(questions),  # ÂêàÂπ∂ÂêéÁöÑÊü•ËØ¢ÊñáÊú¨
                    embd_mdl,  # ÂµåÂÖ•Ê®°ÂûãÔºàÂ∞ÜÊñáÊú¨ËΩ¨‰∏∫ÂêëÈáèÔºâ
                    tenant_ids,  # ÁßüÊà∑ËåÉÂõ¥ÈôêÂà∂
                    dialog.kb_ids,  # Áü•ËØÜÂ∫ìËåÉÂõ¥ÈôêÂà∂
                    1,  # ÂàÜÈ°µÔºöÁ¨¨1È°µ
                    dialog.top_n,  # ËøîÂõûÁâáÊÆµÊï∞ÈáèÔºàÂ¶Ç50‰∏™ÁâáÊÆµÔºâ
                    dialog.similarity_threshold,  # Áõ∏‰ººÂ∫¶ÈòàÂÄºÔºàÂ¶Ç0.7ÔºåËøáÊª§‰∏çÁõ∏ÂÖ≥ÂÜÖÂÆπÔºâ
                    dialog.vector_similarity_weight,  # ÂêëÈáèvsÂÖ≥ÈîÆËØçÊùÉÈáçÂπ≥Ë°°ÔºàÂ¶Ç0.7Ë°®Á§∫70%ÂêëÈáè+30%ÂÖ≥ÈîÆËØçÔºâ
                    doc_ids=attachments,  # Â¶ÇÊûúÁî®Êà∑‰∏ä‰º†‰∫ÜÁâπÂÆöÊñáÊ°£Ôºå‰ºòÂÖàÊ£ÄÁ¥¢Ëøô‰∫õÊñáÊ°£
                    top=dialog.top_k,  # ÈáçÊéíÂ∫èÂêé‰øùÁïôÁöÑÊúÄÁªàÁªìÊûúÊï∞ÔºàÂ¶Ç10‰∏™Ôºâ
                    aggs=False,  # ‰∏çËøõË°åËÅöÂêàÁªüËÆ°
                    rerank_mdl=rerank_mdl,  # ÈáçÊéíÂ∫èÊ®°ÂûãÔºàÊèêÂçáÊ£ÄÁ¥¢Á≤æÂ∫¶Ôºâ
                    rank_feature=label_question(" ".join(questions), kbs),  # ÈóÆÈ¢òÂàÜÁ±ªÁâπÂæÅÔºåËæÖÂä©ÊéíÂ∫è
                )
            # 2. ÁΩëÁªúÊêúÁ¥¢Â¢ûÂº∫ÔºàÂèØÈÄâÔºâ
            if prompt_config.get("tavily_api_key"):
                # ‰ΩøÁî®TavilyËøõË°åÂÆûÊó∂ÁΩëÁªúÊêúÁ¥¢ÔºåËé∑ÂèñÊúÄÊñ∞‰ø°ÊÅØ, ÈÄÇÁî®‰∫éÈúÄË¶ÅÊúÄÊñ∞Êï∞ÊçÆÁöÑÈóÆÈ¢òÔºàÂ¶Ç"‰ªäÂ§©ÁöÑËÇ°‰ª∑"„ÄÅ"ÊúÄÊñ∞Êñ∞Èóª"Á≠âÔºâ
                tav = Tavily(prompt_config["tavily_api_key"])
                tav_res = tav.retrieve_chunks(" ".join(questions))  # Ê£ÄÁ¥¢ÁΩëÁªúÂÜÖÂÆπÂùó
                # Â∞ÜÁΩëÁªúÊêúÁ¥¢ÁªìÊûúÂêàÂπ∂Âà∞Áü•ËØÜÂ∫ìÁªìÊûú‰∏≠
                kbinfos["chunks"].extend(tav_res["chunks"])  # Ê∑ªÂä†ÂÜÖÂÆπÁâáÊÆµ
                kbinfos["doc_aggs"].extend(tav_res["doc_aggs"])  # Ê∑ªÂä†ÊñáÊ°£ÁªüËÆ°

            # 3. Áü•ËØÜÂõæË∞±Ê£ÄÁ¥¢Â¢ûÂº∫ÔºàÂèØÈÄâÔºâ
            if prompt_config.get("use_kg"):
                # ‰ΩøÁî®Áü•ËØÜÂõæË∞±ËøõË°åÁªìÊûÑÂåñÁü•ËØÜÊ£ÄÁ¥¢, Áü•ËØÜÂõæË∞±ÈÄÇÂêàÂ§ÑÁêÜÂÆû‰ΩìÂÖ≥Á≥ª„ÄÅÊ¶ÇÂøµÂ±ÇÊ¨°Á≠âÁªìÊûÑÂåñÈóÆÈ¢ò
                ck = settings.kg_retrievaler.retrieval(
                    " ".join(questions),  # Êü•ËØ¢ÊñáÊú¨
                    tenant_ids,  # ÁßüÊà∑ËåÉÂõ¥
                    dialog.kb_ids,  # Áü•ËØÜÂ∫ìËåÉÂõ¥
                    embd_mdl,  # ÂµåÂÖ•Ê®°Âûã
                    LLMBundle(dialog.tenant_id, LLMType.CHAT))  # LLMÊ®°ÂûãÊùü
                if ck["content_with_weight"]:
                    # Â¶ÇÊûúÁü•ËØÜÂõæË∞±Ê£ÄÁ¥¢Âà∞‰∫ÜÂä†ÊùÉÂÜÖÂÆπÔºåÊèíÂÖ•Âà∞ÁªìÊûúÊúÄÂâçÈù¢
                    # Áü•ËØÜÂõæË∞±ÁöÑÁªìÊûúÈÄöÂ∏∏Êõ¥ÂáÜÁ°ÆÔºåÊâÄ‰ª•‰ºòÂÖàÁ∫ßÊõ¥È´ò
                    kbinfos["chunks"].insert(0, ck)

            # 4. ÁîüÊàêÊúÄÁªàÁöÑÁü•ËØÜÊèêÁ§∫ÊñáÊú¨
            # Â∞ÜÊ£ÄÁ¥¢Âà∞ÁöÑÊâÄÊúâÁü•ËØÜÁâáÊÆµÊ†ºÂºèÂåñ‰∏∫LLMÂèØÁêÜËß£ÁöÑÊèêÁ§∫ÊñáÊú¨
            # ÂêåÊó∂ËÄÉËôëtokenÈôêÂà∂ÔºåÈÅøÂÖçË∂ÖÂá∫Ê®°ÂûãÁöÑ‰∏ä‰∏ãÊñáÈïøÂ∫¶
            knowledges = kb_prompt(kbinfos, max_tokens)

    # ËÆ∞ÂΩïË∞ÉËØï‰ø°ÊÅØÔºöÈóÆÈ¢òÂíåÂØπÂ∫îÁöÑÁü•ËØÜ
    logging.debug("{}->{}".format(" ".join(questions), "\n->".join(knowledges)))

    # ===== Èò∂ÊÆµ8: Ê∂àÊÅØÊûÑÂª∫ =====
    logging.info(" [Èò∂ÊÆµ8] ÂºÄÂßã - Ê∂àÊÅØÊûÑÂª∫")
    retrieval_ts = timer()
    # Â¶ÇÊûúÊ≤°ÊúâÊ£ÄÁ¥¢Âà∞Áü•ËØÜ‰∏îÈÖçÁΩÆ‰∫ÜÁ©∫ÂìçÂ∫î
    if not knowledges and prompt_config.get("empty_response"):
        empty_res = prompt_config["empty_response"]
        # ËøîÂõûÁ©∫ÂìçÂ∫îÁªìÊûú
        yield {"answer": empty_res, "reference": kbinfos, "prompt": "\n\n### Query:\n%s" % " ".join(questions),
               "audio_binary": tts(tts_mdl, empty_res)}
        return {"answer": prompt_config["empty_response"], "reference": kbinfos}

    # Â∞ÜÁü•ËØÜÂÜÖÂÆπÊ∑ªÂä†Âà∞kwargs‰∏≠
    kwargs["knowledge"] = "\n------\n" + "\n\n------\n\n".join(knowledges)
    # Ëé∑ÂèñÁîüÊàêÈÖçÁΩÆ
    gen_conf = dialog.llm_setting
    # ÊûÑÂª∫Ê∂àÊÅØÂàóË°®ÔºåÊ∑ªÂä†Á≥ªÁªüÊèêÁ§∫
    msg = [{"role": "system", "content": prompt_config["system"].format(**kwargs)}]
    # ÂàùÂßãÂåñÂºïÁî®ÊèêÁ§∫
    prompt4citation = ""
    # Â¶ÇÊûúÊúâÁü•ËØÜ‰∏îÈúÄË¶ÅÂºïÁî®
    if knowledges and (prompt_config.get("quote", True) and kwargs.get("quote", True)):
        prompt4citation = citation_prompt()
    # Ê∑ªÂä†ÂéÜÂè≤Ê∂àÊÅØÔºåÁßªÈô§Á≥ªÁªüÊ∂àÊÅØÂíåÂºïÁî®Ê†áËÆ∞
    msg.extend([{"role": m["role"], "content": re.sub(r"##\d+\$\$", "", m["content"])} for m in messages if
                m["role"] != "system"])
    # Á°Æ‰øùÊ∂àÊÅØÂú®tokenÈôêÂà∂ÂÜÖ
    used_token_count, msg = message_fit_in(msg, int(max_tokens * 0.95))
    # Á°Æ‰øùËá≥Â∞ëÊúâÁ≥ªÁªüÊ∂àÊÅØÂíåÁî®Êà∑Ê∂àÊÅØ
    assert len(msg) >= 2, f"message_fit_in has bug: {msg}"
    # Ëé∑ÂèñÊúÄÁªàÁöÑÊèêÁ§∫ÂÜÖÂÆπ
    prompt = msg[0]["content"]

    # Ë∞ÉÊï¥ÁîüÊàêÈÖçÁΩÆ‰∏≠ÁöÑÊúÄÂ§ßtokenÊï∞
    if "max_tokens" in gen_conf:
        gen_conf["max_tokens"] = min(gen_conf["max_tokens"], max_tokens - used_token_count)

    # ===== Èò∂ÊÆµ9: Á≠îÊ°àÁîüÊàê =====
    logging.info(" [Èò∂ÊÆµ9] ÂºÄÂßã - Á≠îÊ°àÁîüÊàê")
    def decorate_answer(answer):
        """
            Ë£ÖÈ•∞Á≠îÊ°àÔºåÊ∑ªÂä†ÂºïÁî®„ÄÅÁªüËÆ°‰ø°ÊÅØÁ≠â.
            Ëøô‰∏™ÂáΩÊï∞ÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™**"ÂêéÂ§ÑÁêÜ+Êä•ÂëäÁîüÊàêÂô®"**Ôºå‰∏ªË¶ÅÂÅö‰∏â‰ª∂‰∫ãÔºö
            1. Ë£ÖÈ•∞Á≠îÊ°àÂÜÖÂÆπ„ÄÇÔºàÂ§ÑÁêÜÂºïÁî®„ÄÅ‰øÆÂ§çÂºïÁî®Ê†ºÂºèÔºâ
            2. ÁîüÊàêÊÄßËÉΩÊä•Âëä„ÄÇÔºàËÆ°ÁÆóÂêÑÈò∂ÊÆµËÄóÊó∂„ÄÅÊûÑÂª∫Êä•ÂëäÊñáÊú¨ prompt += ...  Ê≥®ÊÑèËøô‰∏™promptÊòØÁªôÂ±ïÁ§∫ÁªôÁî®Êà∑ÁöÑË∞ÉËØï‰ø°ÊÅØÔºå‰∏çÊòØÁªôLLMÁöÑÊèêÁ§∫Ôºâ
            3. ËøîÂõûÂÆåÊï¥ÁöÑË∞ÉËØï‰ø°ÊÅØ
        """
        nonlocal embd_mdl, prompt_config, knowledges, kwargs, kbinfos, prompt, retrieval_ts, questions, langfuse_tracer
        # ÂàùÂßãÂåñÂºïÁî®ÂàóË°®
        refs = []
        # ÂàÜÁ¶ªÊÄùËÄÉËøáÁ®ãÂíåÁ≠îÊ°à
        ans = answer.split("</think>")
        think = ""
        if len(ans) == 2:
            think = ans[0] + "</think>"
            answer = ans[1]

        # Â§ÑÁêÜÂºïÁî®ÂíåÂèÇËÄÉÊñáÁåÆ
        if knowledges and (prompt_config.get("quote", True) and kwargs.get("quote", True)):
            idx = set([])
            # Â¶ÇÊûúÊ≤°ÊúâÁé∞ÊúâÂºïÁî®ÔºåËá™Âä®ÊèíÂÖ•ÂºïÁî®
            if embd_mdl and not re.search(r"\[ID:([0-9]+)\]", answer):
                answer, idx = retriever.insert_citations(
                    answer,
                    [ck["content_ltks"] for ck in kbinfos["chunks"]],  # ÂÜÖÂÆπtokens
                    [ck["vector"] for ck in kbinfos["chunks"]],  # ÂêëÈáè
                    embd_mdl,  # ÂµåÂÖ•Ê®°Âûã
                    tkweight=1 - dialog.vector_similarity_weight,  # tokenÊùÉÈáç
                    vtweight=dialog.vector_similarity_weight,  # ÂêëÈáèÊùÉÈáç
                )
            else:
                # ÊèêÂèñÁé∞ÊúâÂºïÁî®ID
                for match in re.finditer(r"\[ID:([0-9]+)\]", answer):
                    i = int(match.group(1))
                    if i < len(kbinfos["chunks"]):
                        idx.add(i)
            # ‰øÆÂ§çÈîôËØØÁöÑÂºïÁî®Ê†ºÂºè
            answer, idx = repair_bad_citation_formats(answer, kbinfos, idx)
            # Ëé∑ÂèñË¢´ÂºïÁî®ÁöÑÊñáÊ°£ID
            idx = set([kbinfos["chunks"][int(i)]["doc_id"] for i in idx])
            # Á≠õÈÄâË¢´ÂºïÁî®ÁöÑÊñáÊ°£
            recall_docs = [d for d in kbinfos["doc_aggs"] if d["doc_id"] in idx]
            if not recall_docs:
                recall_docs = kbinfos["doc_aggs"]
            kbinfos["doc_aggs"] = recall_docs
            # ÂàõÂª∫ÂºïÁî®‰ø°ÊÅØÁöÑÊ∑±Êã∑Ë¥ù
            refs = deepcopy(kbinfos)
            # ÁßªÈô§ÂêëÈáè‰ø°ÊÅØ‰ª•ÂáèÂ∞ëËæìÂá∫Â§ßÂ∞è
            for c in refs["chunks"]:
                if c.get("vector"):
                    del c["vector"]
        # Ê£ÄÊü•APIÂØÜÈí•Áõ∏ÂÖ≥ÈîôËØØ
        if answer.lower().find("invalid key") >= 0 or answer.lower().find("invalid api") >= 0:
            answer += " Please set LLM API-Key in 'User Setting -> Model providers -> API-Key'"
        finish_chat_ts = timer()

        # ËÆ°ÁÆóÂêÑÈò∂ÊÆµËÄóÊó∂ÔºàÊØ´ÁßíÔºâ
        total_time_cost = (finish_chat_ts - chat_start_ts) * 1000
        check_llm_time_cost = (check_llm_ts - chat_start_ts) * 1000
        check_langfuse_tracer_cost = (check_langfuse_tracer_ts - check_llm_ts) * 1000
        bind_embedding_time_cost = (bind_models_ts - check_langfuse_tracer_ts) * 1000
        refine_question_time_cost = (refine_question_ts - bind_models_ts) * 1000
        retrieval_time_cost = (retrieval_ts - refine_question_ts) * 1000
        generate_result_time_cost = (finish_chat_ts - retrieval_ts) * 1000
        # ËÆ°ÁÆóÁîüÊàêÁöÑtokenÊï∞Èáè
        tk_num = num_tokens_from_string(think + answer)
        # ÊûÑÂª∫ÂÆåÊï¥ÁöÑÊèêÁ§∫‰ø°ÊÅØ
        prompt += "\n\n### Query:\n%s" % " ".join(questions)
        prompt = (
            f"{prompt}\n\n"
            "## Time elapsed:\n"
            f"  - Total: {total_time_cost:.1f}ms\n"
            f"  - Check LLM: {check_llm_time_cost:.1f}ms\n"
            f"  - Check Langfuse tracer: {check_langfuse_tracer_cost:.1f}ms\n"
            f"  - Bind models: {bind_embedding_time_cost:.1f}ms\n"
            f"  - Query refinement(LLM): {refine_question_time_cost:.1f}ms\n"
            f"  - Retrieval: {retrieval_time_cost:.1f}ms\n"
            f"  - Generate answer: {generate_result_time_cost:.1f}ms\n\n"
            "## Token usage:\n"
            f"  - Generated tokens(approximately): {tk_num}\n"
            f"  - Token speed: {int(tk_num / (generate_result_time_cost / 1000.0))}/s"
        )
        # ÂáÜÂ§áLangfuseËæìÂá∫‰ø°ÊÅØ
        langfuse_output = "\n" + re.sub(r"^.*?(### Query:.*)", r"\1", prompt, flags=re.DOTALL)
        langfuse_output = {"time_elapsed:": re.sub(r"\n", "  \n", langfuse_output), "created_at": time.time()}

        # Add a condition check to call the end method only if langfuse_tracer exists
        # ÁªìÊùüLangfuseËøΩË∏™ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        if langfuse_tracer and "langfuse_generation" in locals():
            langfuse_generation.end(output=langfuse_output)
        # ËøîÂõûÊúÄÁªàÁªìÊûú
        return {"answer": think + answer, "reference": refs, "prompt": re.sub(r"\n", "  \n", prompt),
                "created_at": time.time()}

    # ÂºÄÂßãLangfuseÁîüÊàêËøΩË∏™
    if langfuse_tracer:
        langfuse_generation = langfuse_tracer.trace.generation(name="chat", model=llm_model_config["llm_name"],
                                                               input={"prompt": prompt,
                                                                      "prompt4citation": prompt4citation,
                                                                      "messages": msg})
    # Ê†πÊçÆstreamÂèÇÊï∞ÈÄâÊã©ÊµÅÂºèÊàñÈùûÊµÅÂºèËæìÂá∫
    if stream:
        last_ans = ""
        answer = ""
        # Ë∞ÉÁî®Â§ßÊ®°ÂûãÔºåÊµÅÂºèÈÄêÊ≠•ÁîüÊàêÁ≠îÊ°à
        print("chat Ë∞ÉÁî®Â§ßÊ®°ÂûãÔºåÊµÅÂºèÈÄêÊ≠•ÁîüÊàêÁ≠îÊ°à")
        for ans in chat_mdl.chat_streamly(prompt + prompt4citation, msg[1:], gen_conf):
            if thought:
                # ÁßªÈô§ÊÄùËÄÉÊ†áÁ≠æÂêéÁöÑÂÜÖÂÆπ
                ans = re.sub(r"^.*</think>", "", ans, flags=re.DOTALL)
            answer = ans
            # ËÆ°ÁÆóÂ¢ûÈáèÁ≠îÊ°à
            delta_ans = ans[len(last_ans):]
            # Â¶ÇÊûúÂ¢ûÈáèÂ§™Â∞èÔºåË∑≥ËøáËæìÂá∫
            if num_tokens_from_string(delta_ans) < 16:
                continue
            last_ans = answer
            # ÊµÅÂºèËæìÂá∫ÂåÖÂê´TTSÈü≥È¢ë
            yield {"answer": thought + answer, "reference": {}, "audio_binary": tts(tts_mdl, delta_ans)}
        # ËæìÂá∫ÊúÄÂêéÁöÑÂ¢ûÈáè
        delta_ans = answer[len(last_ans):]
        if delta_ans:
            yield {"answer": thought + answer, "reference": {}, "audio_binary": tts(tts_mdl, delta_ans)}

        # ËæìÂá∫ÊúÄÁªàË£ÖÈ•∞ÂêéÁöÑÁ≠îÊ°à
        yield decorate_answer(thought + answer)
    else:
        # Ë∞ÉÁî®Â§ßÊ®°ÂûãÔºåÈùûÊµÅÂºèËæìÂá∫
        print("Ë∞ÉÁî®Â§ßÊ®°ÂûãÔºåÈùûÊµÅÂºèËæìÂá∫")
        answer = chat_mdl.chat(prompt + prompt4citation, msg[1:], gen_conf)
        # ËÆ∞ÂΩïÁî®Êà∑ÂíåÂä©ÊâãÁöÑÂØπËØù
        user_content = msg[-1].get("content", "[content not available]")
        logging.debug("User: {}|Assistant: {}".format(user_content, answer))
        # Ë£ÖÈ•∞Á≠îÊ°àÂπ∂Ê∑ªÂä†TTSÈü≥È¢ë
        res = decorate_answer(answer)
        res["audio_binary"] = tts(tts_mdl, answer)
        yield res


def use_sql(question, field_map, tenant_id, chat_mdl, quota=True):
    sys_prompt = "You are a Database Administrator. You need to check the fields of the following tables based on the user's list of questions and write the SQL corresponding to the last question."
    user_prompt = """
Table name: {};
Table of database fields are as follows:
{}

Question are as follows:
{}
Please write the SQL, only SQL, without any other explanations or text.
""".format(index_name(tenant_id), "\n".join([f"{k}: {v}" for k, v in field_map.items()]), question)
    tried_times = 0

    def get_table():
        nonlocal sys_prompt, user_prompt, question, tried_times
        sql = chat_mdl.chat(sys_prompt, [{"role": "user", "content": user_prompt}], {"temperature": 0.06})
        sql = re.sub(r"^.*</think>", "", sql, flags=re.DOTALL)
        logging.debug(f"{question} ==> {user_prompt} get SQL: {sql}")
        sql = re.sub(r"[\r\n]+", " ", sql.lower())
        sql = re.sub(r".*select ", "select ", sql.lower())
        sql = re.sub(r" +", " ", sql)
        sql = re.sub(r"([;Ôºõ]|```).*", "", sql)
        if sql[: len("select ")] != "select ":
            return None, None
        if not re.search(r"((sum|avg|max|min)\(|group by )", sql.lower()):
            if sql[: len("select *")] != "select *":
                sql = "select doc_id,docnm_kwd," + sql[6:]
            else:
                flds = []
                for k in field_map.keys():
                    if k in forbidden_select_fields4resume:
                        continue
                    if len(flds) > 11:
                        break
                    flds.append(k)
                sql = "select doc_id,docnm_kwd," + ",".join(flds) + sql[8:]

        logging.debug(f"{question} get SQL(refined): {sql}")
        tried_times += 1
        return settings.retrievaler.sql_retrieval(sql, format="json"), sql

    tbl, sql = get_table()
    if tbl is None:
        return None
    if tbl.get("error") and tried_times <= 2:
        user_prompt = """
        Table name: {};
        Table of database fields are as follows:
        {}

        Question are as follows:
        {}
        Please write the SQL, only SQL, without any other explanations or text.


        The SQL error you provided last time is as follows:
        {}

        Error issued by database as follows:
        {}

        Please correct the error and write SQL again, only SQL, without any other explanations or text.
        """.format(index_name(tenant_id), "\n".join([f"{k}: {v}" for k, v in field_map.items()]), question, sql,
                   tbl["error"])
        tbl, sql = get_table()
        logging.debug("TRY it again: {}".format(sql))

    logging.debug("GET table: {}".format(tbl))
    if tbl.get("error") or len(tbl["rows"]) == 0:
        return None

    docid_idx = set([ii for ii, c in enumerate(tbl["columns"]) if c["name"] == "doc_id"])
    doc_name_idx = set([ii for ii, c in enumerate(tbl["columns"]) if c["name"] == "docnm_kwd"])
    column_idx = [ii for ii in range(len(tbl["columns"])) if ii not in (docid_idx | doc_name_idx)]

    # compose Markdown table
    columns = (
            "|" + "|".join(
        [re.sub(r"(/.*|Ôºà[^ÔºàÔºâ]+Ôºâ)", "", field_map.get(tbl["columns"][i]["name"], tbl["columns"][i]["name"])) for i in
         column_idx]) + ("|Source|" if docid_idx and docid_idx else "|")
    )

    line = "|" + "|".join(["------" for _ in range(len(column_idx))]) + ("|------|" if docid_idx and docid_idx else "")

    rows = ["|" + "|".join([rmSpace(str(r[i])) for i in column_idx]).replace("None", " ") + "|" for r in tbl["rows"]]
    rows = [r for r in rows if re.sub(r"[ |]+", "", r)]
    if quota:
        rows = "\n".join([r + f" ##{ii}$$ |" for ii, r in enumerate(rows)])
    else:
        rows = "\n".join([r + f" ##{ii}$$ |" for ii, r in enumerate(rows)])
    rows = re.sub(r"T[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+Z)?\|", "|", rows)

    if not docid_idx or not doc_name_idx:
        logging.warning("SQL missing field: " + sql)
        return {"answer": "\n".join([columns, line, rows]), "reference": {"chunks": [], "doc_aggs": []},
                "prompt": sys_prompt}

    docid_idx = list(docid_idx)[0]
    doc_name_idx = list(doc_name_idx)[0]
    doc_aggs = {}
    for r in tbl["rows"]:
        if r[docid_idx] not in doc_aggs:
            doc_aggs[r[docid_idx]] = {"doc_name": r[doc_name_idx], "count": 0}
        doc_aggs[r[docid_idx]]["count"] += 1
    return {
        "answer": "\n".join([columns, line, rows]),
        "reference": {
            "chunks": [{"doc_id": r[docid_idx], "docnm_kwd": r[doc_name_idx]} for r in tbl["rows"]],
            "doc_aggs": [{"doc_id": did, "doc_name": d["doc_name"], "count": d["count"]} for did, d in
                         doc_aggs.items()],
        },
        "prompt": sys_prompt,
    }


def tts(tts_mdl, text):
    if not tts_mdl or not text:
        return
    bin = b""
    for chunk in tts_mdl.tts(text):
        bin += chunk
    return binascii.hexlify(bin).decode("utf-8")


def ask(question, kb_ids, tenant_id):
    print("======asking...")
    kbs = KnowledgebaseService.get_by_ids(kb_ids)
    embedding_list = list(set([kb.embd_id for kb in kbs]))

    is_knowledge_graph = all([kb.parser_id == ParserType.KG for kb in kbs])
    retriever = settings.retrievaler if not is_knowledge_graph else settings.kg_retrievaler

    embd_mdl = LLMBundle(tenant_id, LLMType.EMBEDDING, embedding_list[0])
    chat_mdl = LLMBundle(tenant_id, LLMType.CHAT)
    max_tokens = chat_mdl.max_length
    tenant_ids = list(set([kb.tenant_id for kb in kbs]))
    kbinfos = retriever.retrieval(question, embd_mdl, tenant_ids, kb_ids, 1, 12, 0.1, 0.3, aggs=False,
                                  rank_feature=label_question(question, kbs))
    knowledges = kb_prompt(kbinfos, max_tokens)
    prompt = """
    Role: You're a smart assistant. Your name is Miss R.
    Task: Summarize the information from knowledge bases and answer user's question.
    Requirements and restriction:
      - DO NOT make things up, especially for numbers.
      - If the information from knowledge is irrelevant with user's question, JUST SAY: Sorry, no relevant information provided.
      - Answer with markdown format text.
      - Answer in language of user's question.
      - DO NOT make things up, especially for numbers.

    ### Information from knowledge bases
    %s

    The above is information from knowledge bases.

    """ % "\n".join(knowledges)
    msg = [{"role": "user", "content": question}]

    def decorate_answer(answer):
        nonlocal knowledges, kbinfos, prompt
        answer, idx = retriever.insert_citations(answer, [ck["content_ltks"] for ck in kbinfos["chunks"]],
                                                 [ck["vector"] for ck in kbinfos["chunks"]], embd_mdl, tkweight=0.7,
                                                 vtweight=0.3)
        idx = set([kbinfos["chunks"][int(i)]["doc_id"] for i in idx])
        recall_docs = [d for d in kbinfos["doc_aggs"] if d["doc_id"] in idx]
        if not recall_docs:
            recall_docs = kbinfos["doc_aggs"]
        kbinfos["doc_aggs"] = recall_docs
        refs = deepcopy(kbinfos)
        for c in refs["chunks"]:
            if c.get("vector"):
                del c["vector"]

        if answer.lower().find("invalid key") >= 0 or answer.lower().find("invalid api") >= 0:
            answer += " Please set LLM API-Key in 'User Setting -> Model Providers -> API-Key'"
        refs["chunks"] = chunks_format(refs)
        return {"answer": answer, "reference": refs}

    answer = ""
    print("ask Ë∞ÉÁî®Â§ßÊ®°ÂûãÔºåÊµÅÂºèÈÄêÊ≠•ÁîüÊàêÁ≠îÊ°à")
    for ans in chat_mdl.chat_streamly(prompt, msg, {"temperature": 0.1}):
        answer = ans
        yield {"answer": answer, "reference": {}}
    yield decorate_answer(answer)
